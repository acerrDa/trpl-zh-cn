# 智能指针

> [ch15-00-smart-pointers.md](https://github.com/rust-lang/book/blob/master/second-edition/src/ch15-00-smart-pointers.md)
> <br>
> commit 4f2dc564851dc04b271a2260c834643dfd86c724

**指针**是一个常见的编程概念，它代表一个指向储存其他数据的位置。第四章学习了 Rust 的引用；他们是一类很平常的指针，以`&`符号为标志并借用了他们所指向的值。**智能指针**（*Smart pointers*）是一类数据结构，他们的表现类似指针，但是也拥有额外的元数据和能力，比如说引用计数。智能指针模式起源于 C++。在 Rust 中，普通引用和智能指针的一个额外的区别是引用是一类只借用数据的指针；相反大部分情况，智能指针**拥有**他们指向的数据。

本书中已经出现过一些智能指针，虽然当时我们并不这么称呼他们。例如在某种意义上说，第八章的`String`和`Vec<T>`都是智能指针。他们拥有一些数据并允许你修改他们，并带有元数据（比如他们的容量）和额外的功能或保证（`String`的数据总是有效的 UTF-8 编码）。智能指针区别于常规结构体的特性在于他们实现了`Deref`和`Drop` trait，而本章会讨论这些 trait 以及为什么对于智能指针来说他们很重要。

考虑到智能指针是一个在 Rust 经常被使用的通用设计模式，本章并不会覆盖所有现存的智能指针。很多库都有自己的智能指针而你也可以编写属于你自己的。这里将会讲到的是来自标准库中最常用的一些：

* `Box<T>`，用于在堆上分配值
* `Rc<T>`，一个引用计数类型，其数据可以有多个所有者
* `RefCell<T>`，其本身并不是只能指针，不过它管理智能指针`Ref`和`RefMut`的访问，在运行时而不是在编译时执行借用规则。

同时我们还将涉及：

* **内部可变性**（*interior mutability*）模式，当一个不可变类型暴露出改变其内部值的 API，这时借用规则适用于运行时而不是编译时。
* 引用循环，它如何会泄露内存，以及如何避免他们

让我们开始吧！