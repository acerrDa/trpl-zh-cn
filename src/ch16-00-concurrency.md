# 无畏并发

> [ch16-00-concurrency.md](https://github.com/rust-lang/book/blob/master/second-edition/src/ch16-00-concurrency.md)
> <br>
> commit da15de39eaabd50100d6fa662c653169254d9175

确保内存安全并不是 Rust 的唯一目标：作为一个能更好的处理并发和并行编程一直是 Rust 的另一个主要目标。
**并发编程**（concurrent programming）代表程序的不同部分相互独立的执行，而**并行编程**代表程序不同部分同时执行，这两个概念在计算机拥有更多处理器可供程序利用时变得更加重要。由于历史的原因，在此类上下文中编程一直是困难且容易出错的：Rust 希望能改变这一点。

最开始，我们认为内存安全和防止并发问题是需要通过两个不同的方法解决的两个相互独立的挑战。然而，随着时间的推移，我们发现所有权和类型系统是一系列解决内存安全**和**并发问题的强用力的工具！通过改进所有权和类型检查，很多并发错误在 Rust 中都是**编译时**错误，而不是运行时错误。我们给 Rust 的这一部分起了一个绰号**无畏并发**（*fearless concurrency*）。无畏并发意味着 Rust 不光允许你自信代码不会出现诡异的错误，也让你可以轻易重构这种代码而无需担心会引入新的 bug。

> 注意：对于 Rust 的口号**无畏并发**，这里用**并发**指代很多问题而不是更精确的区分**并发和（或）并行**，是出于简化问题的原因。如果这是一本专注于并发和/或并行的书，我们肯定会更精确的。对于本章，当我们谈到**并发**时，请自行替换为**并发和（或）并行**。

很多语言所提供的处理并发问题的解决方法是非常有自身特色的。这是一个非常合理的策略，尤其是对于更高级的语言来说，不过对于底层语言来说可没有奢侈的选择。底层语言被期望为在任何给定的情况下，都可以使能提供最高性能的解决方案可行，同时他们对硬件有更少的抽象。因此，Rust 给了我们多种工具并以各种适合我们的情况和要求的方式来为问题建模。

如下是本章将要涉及到的内容：

* 如何创建线程来同时运行多段代码。
* 并发**消息传递**（*Message passing*），其中通道（channel）被用来在线程间传递消息。
* 并发**共享状态**（*Shared state*），其中多个线程可以访问同一片数据。
* `Sync`和`Send` trait，他们允许 Rust 的并发保证能被扩展到用户定义的和标准库中提供的类型中。