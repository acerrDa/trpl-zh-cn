<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>trait对象 - Rust 程序设计语言 简体中文版</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Rust 程序设计语言 简体中文版">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href='https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">

        <!-- MathJax -->
        <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>
    </head>
    <body class="light">
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = localStorage.getItem('theme');
            if (theme == null) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = localStorage.getItem('sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li><a href="ch01-00-introduction.html"><strong>1.</strong> 介绍</a></li><li><ul class="section"><li><a href="ch01-01-installation.html"><strong>1.1.</strong> 安装</a></li><li><a href="ch01-02-hello-world.html"><strong>1.2.</strong> Hello, World!</a></li></ul></li><li><a href="ch02-00-guessing-game-tutorial.html"><strong>2.</strong> 猜猜看教程</a></li><li><a href="ch03-00-common-programming-concepts.html"><strong>3.</strong> 通用编程概念</a></li><li><ul class="section"><li><a href="ch03-01-variables-and-mutability.html"><strong>3.1.</strong> 变量和可变性</a></li><li><a href="ch03-02-data-types.html"><strong>3.2.</strong> 数据类型</a></li><li><a href="ch03-03-how-functions-work.html"><strong>3.3.</strong> 函数如何工作</a></li><li><a href="ch03-04-comments.html"><strong>3.4.</strong> 注释</a></li><li><a href="ch03-05-control-flow.html"><strong>3.5.</strong> 控制流</a></li></ul></li><li><a href="ch04-00-understanding-ownership.html"><strong>4.</strong> 认识所有权</a></li><li><ul class="section"><li><a href="ch04-01-what-is-ownership.html"><strong>4.1.</strong> 什么是所有权</a></li><li><a href="ch04-02-references-and-borrowing.html"><strong>4.2.</strong> 引用 &amp; 借用</a></li><li><a href="ch04-03-slices.html"><strong>4.3.</strong> Slices</a></li></ul></li><li><a href="ch05-00-structs.html"><strong>5.</strong> 结构体</a></li><li><ul class="section"><li><a href="ch05-01-method-syntax.html"><strong>5.1.</strong> 方法语法</a></li></ul></li><li><a href="ch06-00-enums.html"><strong>6.</strong> 枚举和模式匹配</a></li><li><ul class="section"><li><a href="ch06-01-defining-an-enum.html"><strong>6.1.</strong> 定义枚举</a></li><li><a href="ch06-02-match.html"><strong>6.2.</strong> <code>match</code>控制流运算符</a></li><li><a href="ch06-03-if-let.html"><strong>6.3.</strong> <code>if let</code>简单控制流</a></li></ul></li><li><a href="ch07-00-modules.html"><strong>7.</strong> 模块</a></li><li><ul class="section"><li><a href="ch07-01-mod-and-the-filesystem.html"><strong>7.1.</strong> <code>mod</code>和文件系统</a></li><li><a href="ch07-02-controlling-visibility-with-pub.html"><strong>7.2.</strong> 使用<code>pub</code>控制可见性</a></li><li><a href="ch07-03-importing-names-with-use.html"><strong>7.3.</strong> 使用<code>use</code>导入命名</a></li></ul></li><li><a href="ch08-00-common-collections.html"><strong>8.</strong> 通用集合类型</a></li><li><ul class="section"><li><a href="ch08-01-vectors.html"><strong>8.1.</strong> vector</a></li><li><a href="ch08-02-strings.html"><strong>8.2.</strong> 字符串</a></li><li><a href="ch08-03-hash-maps.html"><strong>8.3.</strong> 哈希 map</a></li></ul></li><li><a href="ch09-00-error-handling.html"><strong>9.</strong> 错误处理</a></li><li><ul class="section"><li><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong>9.1.</strong> <code>panic!</code>与不可恢复的错误</a></li><li><a href="ch09-02-recoverable-errors-with-result.html"><strong>9.2.</strong> <code>Result</code>与可恢复的错误</a></li><li><a href="ch09-03-to-panic-or-not-to-panic.html"><strong>9.3.</strong> <code>panic!</code>还是不<code>panic!</code></a></li></ul></li><li><a href="ch10-00-generics.html"><strong>10.</strong> 泛型、trait 和生命周期</a></li><li><ul class="section"><li><a href="ch10-01-syntax.html"><strong>10.1.</strong> 泛型数据类型</a></li><li><a href="ch10-02-traits.html"><strong>10.2.</strong> trait：定义共享的行为</a></li><li><a href="ch10-03-lifetime-syntax.html"><strong>10.3.</strong> 生命周期与引用有效性</a></li></ul></li><li><a href="ch11-00-testing.html"><strong>11.</strong> 测试</a></li><li><ul class="section"><li><a href="ch11-01-writing-tests.html"><strong>11.1.</strong> 编写测试</a></li><li><a href="ch11-02-running-tests.html"><strong>11.2.</strong> 运行测试</a></li><li><a href="ch11-03-test-organization.html"><strong>11.3.</strong> 测试的组织结构</a></li></ul></li><li><a href="ch12-00-an-io-project.html"><strong>12.</strong> 一个 I/O 项目</a></li><li><ul class="section"><li><a href="ch12-01-accepting-command-line-arguments.html"><strong>12.1.</strong> 接受命令行参数</a></li><li><a href="ch12-02-reading-a-file.html"><strong>12.2.</strong> 读取文件</a></li><li><a href="ch12-03-improving-error-handling-and-modularity.html"><strong>12.3.</strong> 增强错误处理和模块化</a></li><li><a href="ch12-04-testing-the-librarys-functionality.html"><strong>12.4.</strong> 测试库的功能</a></li><li><a href="ch12-05-working-with-environment-variables.html"><strong>12.5.</strong> 处理环境变量</a></li><li><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong>12.6.</strong> 输出到<code>stderr</code>而不是<code>stdout</code></a></li></ul></li><li><a href="ch13-00-functional-features.html"><strong>13.</strong> Rust 中的函数式语言功能</a></li><li><ul class="section"><li><a href="ch13-01-closures.html"><strong>13.1.</strong> 闭包</a></li><li><a href="ch13-02-iterators.html"><strong>13.2.</strong> 迭代器</a></li><li><a href="ch13-03-improving-our-io-project.html"><strong>13.3.</strong> 改进 I/O 项目</a></li><li><a href="ch13-04-performance.html"><strong>13.4.</strong> 性能</a></li></ul></li><li><a href="ch14-00-more-about-cargo.html"><strong>14.</strong> 更多关于 Cargo 和 Crates.io</a></li><li><ul class="section"><li><a href="ch14-01-release-profiles.html"><strong>14.1.</strong> 发布配置</a></li><li><a href="ch14-02-publishing-to-crates-io.html"><strong>14.2.</strong> 将 crate 发布到 Crates.io</a></li><li><a href="ch14-03-cargo-workspaces.html"><strong>14.3.</strong> Cargo 工作空间</a></li><li><a href="ch14-04-installing-binaries.html"><strong>14.4.</strong> 使用<code>cargo install</code>从 Crates.io 安装文件</a></li><li><a href="ch14-05-extending-cargo.html"><strong>14.5.</strong> Cargo 自定义扩展命令</a></li></ul></li><li><a href="ch15-00-smart-pointers.html"><strong>15.</strong> 智能指针</a></li><li><ul class="section"><li><a href="ch15-01-box.html"><strong>15.1.</strong> <code>Box&lt;T&gt;</code>用于已知大小的堆上数据</a></li><li><a href="ch15-02-deref.html"><strong>15.2.</strong> <code>Deref</code> Trait 允许通过引用访问数据</a></li><li><a href="ch15-03-drop.html"><strong>15.3.</strong> <code>Drop</code> Trait 运行清理代码</a></li><li><a href="ch15-04-rc.html"><strong>15.4.</strong> <code>Rc&lt;T&gt;</code> 引用计数智能指针</a></li><li><a href="ch15-05-interior-mutability.html"><strong>15.5.</strong> <code>RefCell&lt;T&gt;</code>和内部可变性模式</a></li><li><a href="ch15-06-reference-cycles.html"><strong>15.6.</strong> 引用循环和内存泄漏是安全的</a></li></ul></li><li><a href="ch16-00-concurrency.html"><strong>16.</strong> 无畏并发</a></li><li><ul class="section"><li><a href="ch16-01-threads.html"><strong>16.1.</strong> 线程</a></li><li><a href="ch16-02-message-passing.html"><strong>16.2.</strong> 消息传递</a></li><li><a href="ch16-03-shared-state.html"><strong>16.3.</strong> 共享状态</a></li><li><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong>16.4.</strong> 可扩展的并发：<code>Sync</code>和<code>Send</code></a></li></ul></li><li><a href="ch17-00-oop.html"><strong>17.</strong> 面向对象</a></li><li><ul class="section"><li><a href="ch17-01-what-is-oo.html"><strong>17.1.</strong> 什么是面向对象</a></li><li><a href="ch17-02-trait-objects.html" class="active"><strong>17.2.</strong> trait对象</a></li></ul></li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush"></i>
                    </div>

                    <h1 class="menu-title">Rust 程序设计语言 简体中文版</h1>

                    <div class="right-buttons">
                        <i id="print-button" class="fa fa-print" title="Print this book"></i>
                    </div>
                </div>

                <div id="content" class="content">
                    <a class="header" href="#为使用不同类型的值而设计的trait对象" name="为使用不同类型的值而设计的trait对象"><h2>为使用不同类型的值而设计的Trait对象</h2></a>
<blockquote>
<p><a href="https://github.com/rust-lang/book/blob/master/second-edition/src/ch17-02-trait-objects.md">ch17-02-trait-objects.md</a>
<br>
commit 872dc793f7017f815fb1e5389200fd208e12792d</p>
</blockquote>
<p>在第8章，我们谈到了vector的局限是vectors只能存储同种类型的元素。我们在Listing 8-1有一个例子，其中定义了一个<code>SpreadsheetCell</code> 枚举类型，可以存储整形、浮点型和text，这样我们就可以在每个cell存储不同的数据类型了，同时还有一个代表一行cell的vector。当我们的代码编译的时候，如果交换地处理的各种东西是固定的类型是已知的，那么这是可行的。</p>
<pre><code>&lt;!-- The code example I want to reference did not have a listing number; it's
the one with SpreadsheetCell. I will go back and add Listing 8-1 next time I
get Chapter 8 for editing. /Carol --&gt;
</code></pre>
<p>有时，我们想我们使用的类型集合是可扩展的，可以被使用我们的库的程序员扩展。比如很多图形化接口工具有一个条目列表，从这个列表迭代和调用draw方法在每个条目上。我们将要创建一个库crate，包含称为<code>rust_gui</code>的CUI库的结构体。我们的GUI库可以包含一些给开发者使用的类型，比如<code>Button</code>或者<code>TextField</code>。使用<code>rust_gui</code>的程序员会创建更多可以在屏幕绘图的类型：一个程序员可能会增加<code>Image</code>，另外一个可能会增加<code>SelectBox</code>。我们不会在本章节实现一个完善的GUI库，但是我们会展示如何把各部分组合在一起。</p>
<p>当要写一个<code>rust_gui</code>库时，我们不知道其他程序员要创建什么类型，所以我们无法定义一个<code>enum</code>来包含所有的类型。我们知道的是<code>rust_gui</code>需要有能力跟踪所有这些不同类型的大量的值，需要有能力在每个值上调用<code>draw</code>方法。我们的GUI库不需要确切地知道当调用<code>draw</code>方法时会发生什么，只要值有可用的方法供我们调用就可以。</p>
<p>在有继承的语言里，我们可能会定义一个名为<code>Component</code>的类，该类上有一个<code>draw</code>方法。其他的类比如<code>Button</code>、<code>Image</code>和<code>SelectBox</code>会从<code>Component</code>继承并继承<code>draw</code>方法。它们会各自覆写<code>draw</code>方法来自定义行为，但是框架会把所有的类型当作是<code>Component</code>的实例，并在它们上调用<code>draw</code>。</p>
<a class="header" href="#定义一个带有自定义行为的trait" name="定义一个带有自定义行为的trait"><h3>定义一个带有自定义行为的Trait</h3></a>
<p>不过，在Rust语言中，我们可以定义一个名为<code>Draw</code>的trait，其上有一个名为<code>draw</code>的方法。我们定义一个带有<em>trait对象</em>的vector，绑定了一种指针的trait，比如<code>&amp;</code>引用或者一个<code>Box&lt;T&gt;</code>智能指针。</p>
<p>我们提到，我们不会调用结构体和枚举的对象，从而区分于其他语言的对象。在结构体的数据或者枚举的字段和<code>impl</code>块中的行为是分开的，而其他语言则是数据和行为被组合到一个概念里。Trait对象更像其他语言的对象，在这种场景下，他们组合了由指针组成的数据到实体对象，该对象带有在trait中定义的方法行为。但是，trait对象是和其他语言是不同的，因为我们不能向一个trait对象增加数据。trait对象不像其他语言那样有用：它们的目的是允许从公有的行为上抽象。</p>
<p>trait定义了在给定场景下我们所需要的行为。在我们会使用一个实体类型或者一个通用类型的地方，我们可以把trait当作trait对象使用。Rust的类型系统会保证我们为trait对象带入的任何值会实现trait的方法。我们不需要在编译阶段知道所有可能的类型，我们可以把所有的实例统一对待。Listing 17-03展示了如何定义一个名为<code>Draw</code>的带有<code>draw</code>方法的trait。</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust">pub trait Draw {
    fn draw(&amp;self);
}
</code></pre>
<p><span class="caption">Listing 17-3:<code>Draw</code> trait的定义</span></p>
<!-- NEXT PARAGRAPH WRAPPED WEIRD INTENTIONALLY SEE #199 -->
<p>因为我们已经在第10章讨论过如何定义trait，你可能比较熟悉。下面是新的定义：Listing 17-4有一个名为<code>Screen</code>的结构体，里面有一个名为<code>components</code>的vector，<code>components</code>的类型是Box<Draw>。<code>Box&lt;Draw&gt;</code>是一个trait对象：它是一个任何<code>Box</code>内部的实现了<code>Draw</code>trait的类型的替身。</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust"># pub trait Draw {
#     fn draw(&amp;self);
# }
#
pub struct Screen {
    pub components: Vec&lt;Box&lt;Draw&gt;&gt;,
}
</code></pre>
<p><span class="caption">Listing 17-4: 定义一个<code>Screen</code>结构体，带有一个含有实现了<code>Draw</code>trait的<code>components</code> vector成员</p>
<p></span></p>
<p>在<code>Screen</code>结构体上，我们将要定义一个<code>run</code>方法，该方法会在它的<code>components</code>上调用<code>draw</code>方法，如Listing 17-5所示：</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust"># pub trait Draw {
#     fn draw(&amp;self);
# }
#
# pub struct Screen {
#     pub components: Vec&lt;Box&lt;Draw&gt;&gt;,
# }
#
impl Screen {
    pub fn run(&amp;self) {
        for component in self.components.iter() {
            component.draw();
        }
    }
}
</code></pre>
<p><span class="caption">Listing 17-5:在<code>Screen</code>上实现一个<code>run</code>方法，该方法在每个组件上调用<code>draw</code>方法
</span></p>
<p>这是区别于定义一个使用带有trait绑定的通用类型参数的结构体。通用类型参数一次只能被一个实体类型替代，而trait对象可以在运行时允许多种实体类型填充trait对象。比如，我们已经定义了<code>Screen</code>结构体使用通用类型和一个trait绑定，如Listing 17-6所示：</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust"># pub trait Draw {
#     fn draw(&amp;self);
# }
#
pub struct Screen&lt;T: Draw&gt; {
    pub components: Vec&lt;T&gt;,
}

impl&lt;T&gt; Screen&lt;T&gt;
    where T: Draw {
    pub fn run(&amp;self) {
        for component in self.components.iter() {
            component.draw();
        }
    }
}
</code></pre>
<p><span class="caption">Listing 17-6: 一种<code>Screen</code>结构体的替代实现，它的<code>run</code>方法使用通用类型和trait绑定
</span></p>
<p>这个例子只能使我们有一个<code>Screen</code>实例，这个实例有一个组件列表，所有的组件类型是<code>Button</code>或者<code>TextField</code>。如果你有同种的集合，那么可以优先使用通用和trait绑定，这是因为为了使用具体的类型，定义是在编译阶段是单一的。</p>
<p>而如果使用内部有<code>Vec&lt;Box&lt;Draw&gt;&gt;</code> trait对象的列表的<code>Screen</code>结构体，<code>Screen</code>实例可以同时包含<code>Box&lt;Button&gt;</code>和<code>Box&lt;TextField&gt;</code>的<code>Vec</code>。我们看它是怎么工作的，然后讨论运行时性能的实现。</p>
<a class="header" href="#来自我们或者库使用者的实现" name="来自我们或者库使用者的实现"><h3>来自我们或者库使用者的实现</h3></a>
<p>现在，我们增加一些实现了<code>Draw</code>trait的类型。我们会再次提供<code>Button</code>，实际上实现一个GUI库超出了本书的范围，所以<code>draw</code>方法的内部不会有任何有用的实现。为了想象一下实现可能的样子，<code>Button</code>结构体可能有 width<code>、</code>height<code>和</code>label`字段，如Listing 17-7所示：</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust"># pub trait Draw {
#     fn draw(&amp;self);
# }
#
pub struct Button {
    pub width: u32,
    pub height: u32,
    pub label: String,
}

impl Draw for Button {
    fn draw(&amp;self) {
        // Code to actually draw a button
    }
}
</code></pre>
<p><span class="caption">Listing 17-7: 实现了<code>Draw</code> trait的<code>Button</code> 结构体</span></p>
<p>在<code>Button</code>上的 <code>width</code>、<code>height</code>和<code>label</code>会和其他组件不同，比如<code>TextField</code>可能有<code>width</code>、<code>height</code>,
<code>label</code>和 <code>placeholder</code>字段。每个我们可以在屏幕上绘制的类型会实现<code>Draw</code>trait，在<code>draw</code>方法中使用不同的代码，定义了如何绘制<code>Button</code>（GUI代码的具体实现超出了本章节的范围）。除了<code>Draw</code> trait，<code>Button</code>可能也有另一个<code>impl</code>块，包含了当按钮被点击的时候的响应方法。这类方法不适用于<code>TextField</code>这样的类型。</p>
<p>有时，使用我们的库决定了实现一个包含<code>width</code>、<code>height</code>和<code>options``SelectBox</code>结构体。它们在<code>SelectBox</code>类型上实现了<code>Draw</code>trait，如 Listing 17-8所示：</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust,ignore">extern crate rust_gui;
use rust_gui::Draw;

struct SelectBox {
    width: u32,
    height: u32,
    options: Vec&lt;String&gt;,
}

impl Draw for SelectBox {
    fn draw(&amp;self) {
        // Code to actually draw a select box
    }
}
</code></pre>
<p><span class="caption">Listing 17-8: 另外一个crate中，在<code>SelectBox</code>结构体上使用<code>rust_gui</code>和实现了<code>Draw</code> trait
</span></p>
<p>我们的库的使用者现在可以写他们的<code>main</code>函数来创建一个<code>Screen</code>实例，然后通过把自身放入<code>Box&lt;T&gt;</code>变成trait对象，向screen增加<code>SelectBox</code> 和<code>Button</code>。它们可以在每个<code>Screen</code>实例上调用<code>run</code>方法，这会调用每个组件的<code>draw</code>方法。 Listing 17-9展示了实现：</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust,ignore">use rust_gui::{Screen, Button};

fn main() {
    let screen = Screen {
        components: vec![
            Box::new(SelectBox {
                width: 75,
                height: 10,
                options: vec![
                    String::from(&quot;Yes&quot;),
                    String::from(&quot;Maybe&quot;),
                    String::from(&quot;No&quot;)
                ],
            }),
            Box::new(Button {
                width: 50,
                height: 10,
                label: String::from(&quot;OK&quot;),
            }),
        ],
    };

    screen.run();
}
</code></pre>
<p><span class="caption">Listing 17-9: 使用trait对象来存储实现了相同trait的不同类型
</span></p>
<p>虽然我们不知道有些人可能有一天会增加<code>SelectBox</code>类型，但是我们的<code>Screen</code> 有能力操作<code>SelectBox</code>和绘制，因为<code>SelectBox</code>实现了<code>Draw</code>类型，这意味着它实现了<code>draw</code>方法。</p>
<p>只关心值响应的消息，而不关心值的具体类型，这类似于动态类型语言中的<em>duck typing</em>：如果它像鸭子一样走路，像鸭子一样叫，那么它肯定是只鸭子！在Listing 17-5的<code>Screen</code>的<code>run</code>方法的实现中，<code>run</code>不需要知道每个组件的具体类型。它也不检查是否一个组件是<code>Button</code>或者<code>SelectBox</code>的实例，只是调用组件的<code>draw</code>方法即可。通过指定<code>Box&lt;Draw&gt;</code>作为<code>components</code>vector中的值类型，我们定义了：<code>Screen</code>需要可以被调用其<code>draw</code>方法的值。</p>
<p>使用trait对象和支持duck typing的Rust类型系统的好处是，我们永远不需要在运行时检查一个值是否实现了一个特殊方法，或者担心因为调用了一个值没有实现方法而遇到错误。如果值没有实现trait对象需要的trait，Rust不会编译我们的代码。</p>
<p>比如，Listing 17-10展示了当我们创建一个把<code>String</code>当做其成员的<code>Screen</code>时发生的情况：</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust,ignore">extern crate rust_gui;
use rust_gui::Draw;

fn main() {
    let screen = Screen {
        components: vec![
            Box::new(String::from(&quot;Hi&quot;)),
        ],
    };

    screen.run();
}
</code></pre>
<p><span class="caption">Listing 17-10: 尝试使用一种没有实现trait对象的trait的类型</p>
<p></span></p>
<p>我们会遇到这个错误，因为<code>String</code>没有实现 <code>Draw</code>trait：</p>
<pre><code class="language-text">error[E0277]: the trait bound `std::string::String: Draw` is not satisfied
  --&gt;
   |
 4 |             Box::new(String::from(&quot;Hi&quot;)),
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Draw` is not
   implemented for `std::string::String`
   |
   = note: required for the cast to the object type `Draw`
</code></pre>
<p>这个报错让我们知道，或者我们传入了本来不想传给<code>Screen</code>的东西，我们应该传入一个不同的类型，或者是我们应该在<code>String</code>上实现<code>Draw</code>，这样，<code>Screen</code>才能调用它的<code>draw</code>方法。</p>
<a class="header" href="#trait对象执行动态分发" name="trait对象执行动态分发"><h3>Trait对象执行动态分发</h3></a>
<p>回忆一下第10章，我们讨论过当我们使用通用类型的trait绑定时，编译器执行单类型的处理过程：在我们需要使用通用类型参数的地方，编译器为每个实体类型产生了非通用的函数实现和方法。由于非单类型而产生的代码是 <em>static dispatch</em>：当方法被调用，代码会执行在编译阶段就决定的方法，这样寻找那段代码是非常快速的。</p>
<p>当我们使用trait对象，编译器不能执行单类型的，因为我们不知道可能被代码调用的类型。而，当方法被调用的时候，Rust跟踪可能被使用的代码，然后在运行时找出为了方法被调用时该使用哪些代码。这也是我们熟知的<em>dynamic dispatch</em>，当运行时的查找发生时是比较耗费资源的。动态分发也防止编译器选择内联函数的代码，这样防止了一些优化。虽然我们写代码时得到了额外的代码灵活性，不过，这是一个权衡考虑。</p>
<a class="header" href="#trait-对象需要对象安全" name="trait-对象需要对象安全"><h3>Trait 对象需要对象安全</h3></a>
<!-- Liz: we're conflicted on including this section. Not being able to use a
trait as a trait object because of object safety is something that
beginner/intermediate Rust developers run into sometimes, but explaining it
fully is long and complicated. Should we just cut this whole section? Leave it
(and finish the explanation of how to fix the error at the end)? Shorten it to
a quick caveat, that just says something like "Some traits can't be trait
objects. Clone is an example of one. You'll get errors that will let you know
if a trait can't be a trait object, look up object safety if you're interested
in the details"? Thanks! /Carol -->
<p>Not all traits can be made into trait objects; only <em>object safe</em> traits can. A
trait is object safe as long as both of the following are true:</p>
<ul>
<li>The trait does not require <code>Self</code> to be <code>Sized</code></li>
<li>All of the trait's methods are object safe.</li>
</ul>
<p><code>Self</code> is a keyword that is an alias for the type that we're implementing
traits or methods on. <code>Sized</code> is a marker trait like the <code>Send</code> and <code>Sync</code>
traits that we talked about in Chapter 16. <code>Sized</code> is automatically implemented
on types that have a known size at compile time, such as <code>i32</code> and references.
Types that do not have a known size include slices (<code>[T]</code>) and trait objects.</p>
<p><code>Sized</code> is an implicit trait bound on all generic type parameters by default.
Most useful operations in Rust require a type to be <code>Sized</code>, so making <code>Sized</code>
a default requirement on trait bounds means we don't have to write <code>T: Sized</code>
with most every use of generics. If we want to be able to use a trait on
slices, however, we need to opt out of the <code>Sized</code> trait bound, and we can do
that by specifying <code>T: ?Sized</code> as a trait bound.</p>
<p>Traits have a default bound of <code>Self: ?Sized</code>, which means that they can be
implemented on types that may or may not be <code>Sized</code>. If we create a trait <code>Foo</code>
that opts out of the <code>Self: ?Sized</code> bound, that would look like the following:</p>
<pre><code class="language-rust">trait Foo: Sized {
    fn some_method(&amp;self);
}
</code></pre>
<p>The trait <code>Sized</code> is now a <em>super trait</em> of trait <code>Foo</code>, which means trait
<code>Foo</code> requires types that implement <code>Foo</code> (that is, <code>Self</code>) to be <code>Sized</code>.
We're going to talk about super traits in more detail in Chapter 19.</p>
<p>The reason a trait like <code>Foo</code> that requires <code>Self</code> to be <code>Sized</code> is not allowed
to be a trait object is that it would be impossible to implement the trait
<code>Foo</code> for the trait object <code>Foo</code>: trait objects aren't sized, but <code>Foo</code>
requires <code>Self</code> to be <code>Sized</code>. A type can't be both sized and unsized at the
same time!</p>
<p>For the second object safety requirement that says all of a trait's methods
must be object safe, a method is object safe if either:</p>
<ul>
<li>It requires <code>Self</code> to be <code>Sized</code> or</li>
<li>It meets all three of the following:
<ul>
<li>It must not have any generic type parameters</li>
<li>Its first argument must be of type <code>Self</code> or a type that dereferences to
the Self type (that is, it must be a method rather than an associated
function and have <code>self</code>, <code>&amp;self</code>, or <code>&amp;mut self</code> as the first argument)</li>
<li>It must not use <code>Self</code> anywhere else in the signature except for the
first argument</li>
</ul>
</li>
</ul>
<p>Those rules are a bit formal, but think of it this way: if your method requires
the concrete <code>Self</code> type somewhere in its signature, but an object forgets the
exact type that it is, there's no way that the method can use the original
concrete type that it's forgotten. Same with generic type parameters that are
filled in with concrete type parameters when the trait is used: the concrete
types become part of the type that implements the trait. When the type is
erased by the use of a trait object, there's no way to know what types to fill
in the generic type parameters with.</p>
<p>An example of a trait whose methods are not object safe is the standard
library's <code>Clone</code> trait. The signature for the <code>clone</code> method in the <code>Clone</code>
trait looks like this:</p>
<pre><code class="language-rust">pub trait Clone {
    fn clone(&amp;self) -&gt; Self;
}
</code></pre>
<p><code>String</code> implements the <code>Clone</code> trait, and when we call the <code>clone</code> method on
an instance of <code>String</code> we get back an instance of <code>String</code>. Similarly, if we
call <code>clone</code> on an instance of <code>Vec</code>, we get back an instance of <code>Vec</code>. The
signature of <code>clone</code> needs to know what type will stand in for <code>Self</code>, since
that's the return type.</p>
<p>If we try to implement <code>Clone</code> on a trait like the <code>Draw</code> trait from Listing
17-3, we wouldn't know whether <code>Self</code> would end up being a <code>Button</code>, a
<code>SelectBox</code>, or some other type that will implement the <code>Draw</code> trait in the
future.</p>
<p>The compiler will tell you if you're trying to do something that violates the
rules of object safety in regards to trait objects. For example, if we had
tried to implement the <code>Screen</code> struct in Listing 17-4 to hold types that
implement the <code>Clone</code> trait instead of the <code>Draw</code> trait, like this:</p>
<pre><code class="language-rust,ignore">pub struct Screen {
    pub components: Vec&lt;Box&lt;Clone&gt;&gt;,
}
</code></pre>
<p>We'll get this error:</p>
<pre><code class="language-text">error[E0038]: the trait `std::clone::Clone` cannot be made into an object
 --&gt;
  |
2 |     pub components: Vec&lt;Box&lt;Clone&gt;&gt;,
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `std::clone::Clone` cannot be
  made into an object
  |
  = note: the trait cannot require that `Self : Sized`
</code></pre>
<!-- If we are including this section, we would explain how to fix this
problem. It involves adding another trait and implementing Clone manually for
that trait. Because this section is getting long, I stopped because it feels
like we're off in the weeds with an esoteric detail that not everyone will need
to know about. /Carol -->

                </div>

                <!-- Mobile navigation buttons -->
                
                    <a href="ch17-01-what-is-oo.html" class="mobile-nav-chapters previous">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                

            </div>

            
                <a href="ch17-01-what-is-oo.html" class="nav-chapters previous" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-left"></i>
                </a>
            

            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <!-- Livereload script (if served using the cli tool) -->
        

        <script src="highlight.js"></script>
        <script src="book.js"></script>
    </body>
</html>
